<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Collaborative Bingo</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script>
    // Initialize Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyB8mAy3uo_u_IF-qwzKe8UVlmye_jzoyYo",
      authDomain: "bingo-card-89c49.firebaseapp.com",
      databaseURL: "https://bingo-card-89c49-default-rtdb.firebaseio.com",
      projectId: "bingo-card-89c49",
      storageBucket: "bingo-card-89c49.firebasestorage.app",
      messagingSenderId: "655375255618",
      appId: "1:655375255618:web:c02cc985aaf5aa8e0b85db"
    };
    
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
  </script>
  
  <script type="text/babel">
    const { useState, useEffect } = React;

    const BingoCard = () => {
      const [cells, setCells] = useState([]);
      const [selectedColor, setSelectedColor] = useState(0);
      const [loading, setLoading] = useState(true);
      const [lastUpdate, setLastUpdate] = useState(null);
      const [adminMode, setAdminMode] = useState(false);
      const [showRules, setShowRules] = useState(false);

      const colors = [
        { name: 'Danny', bg: 'bg-red-500', border: 'border-red-500', text: 'text-red-500', hex: '#ef4444' },
        { name: 'Daniel', bg: 'bg-blue-500', border: 'border-blue-500', text: 'text-blue-500', hex: '#3b82f6' },
        { name: 'Gabriel', bg: 'bg-green-500', border: 'border-green-500', text: 'text-green-500', hex: '#22c55e' },
        { name: 'Panos', bg: 'bg-yellow-500', border: 'border-yellow-500', text: 'text-yellow-500', hex: '#eab308' },
        { name: 'Peter', bg: 'bg-purple-500', border: 'border-purple-500', text: 'text-purple-500', hex: '#a855f7' },
        { name: 'Kameron', bg: 'bg-orange-500', border: 'border-orange-500', text: 'text-orange-500', hex: '#f97316' }
      ];

      const defaultConfig = {
        cells: [
          'Free Space', 'Item 2', 'Item 3', 'Item 4', 'Item 5', 'Item 6',
          'Item 7', 'Item 8', 'Item 9', 'Item 10', 'Item 11', 'Item 12',
          'Item 13', 'Item 14', 'Item 15', 'Item 16', 'Item 17', 'Item 18',
          'Item 19', 'Item 20', 'Item 21', 'Item 22', 'Item 23', 'Item 24',
          'Item 25', 'Item 26', 'Item 27', 'Item 28', 'Item 29', 'Item 30',
          'Item 31', 'Item 32', 'Item 33', 'Item 34', 'Item 35', 'Item 36'
        ],
        discordWebhook: ''
      };

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        setAdminMode(params.get('admin') === 'true');
        
        loadData();
        
        // Listen for real-time updates
        const marksRef = database.ref('bingo-marks');
        const configRef = database.ref('bingo-config');
        
        marksRef.on('value', (snapshot) => {
          loadData();
        });
        
        return () => {
          marksRef.off();
        };
      }, []);

      const loadData = async () => {
        try {
          const marksSnapshot = await database.ref('bingo-marks').once('value');
          const configSnapshot = await database.ref('bingo-config').once('value');
          
          const marks = marksSnapshot.val() || Array(36).fill([]);
          const config = configSnapshot.val() || defaultConfig;
          
          setCells(config.cells.map((text, i) => ({
            text,
            colors: marks[i] || []
          })));
          
          setLoading(false);
        } catch (error) {
          console.error('Error loading data:', error);
          setCells(defaultConfig.cells.map((text, i) => ({
            text,
            colors: []
          })));
          setLoading(false);
        }
      };

      const saveMarks = async (newCells) => {
        const marks = newCells.map(cell => cell.colors);
        await database.ref('bingo-marks').set(marks);
      };

      const generateBingoImage = (cellsData) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 100;
        const gridSize = 6;
        const canvasSize = cellSize * gridSize;
        
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasSize, canvasSize);
        
        cellsData.forEach((cell, idx) => {
          const row = Math.floor(idx / 6);
          const col = idx % 6;
          const x = col * cellSize;
          const y = row * cellSize;
          
          if (cell.colors.length > 0) {
            cell.colors.forEach((colorIdx, i) => {
              ctx.fillStyle = colors[colorIdx].hex;
              ctx.globalAlpha = 0.3;
              
              if (cell.colors.length === 1) {
                ctx.fillRect(x, y, cellSize, cellSize);
              } else if (cell.colors.length === 2) {
                ctx.fillRect(x + (i * cellSize / 2), y, cellSize / 2, cellSize);
              } else if (cell.colors.length === 3) {
                // 3 colors: 2 columns, 2 rows (one cell empty)
                const quadX = i % 2;
                const quadY = Math.floor(i / 2);
                ctx.fillRect(x + (quadX * cellSize / 2), y + (quadY * cellSize / 2), cellSize / 2, cellSize / 2);
              } else if (cell.colors.length === 4) {
                // 4 colors: 2x2 grid
                const quadX = i % 2;
                const quadY = Math.floor(i / 2);
                ctx.fillRect(x + (quadX * cellSize / 2), y + (quadY * cellSize / 2), cellSize / 2, cellSize / 2);
              } else if (cell.colors.length === 5) {
                // 5 colors: 2 columns, 3 rows
                const colX = i % 2;
                const rowY = Math.floor(i / 2);
                ctx.fillRect(x + (colX * cellSize / 2), y + (rowY * cellSize / 3), cellSize / 2, cellSize / 3);
              } else {
                // 6 colors: 2 columns, 3 rows
                const colX = i % 2;
                const rowY = Math.floor(i / 2);
                ctx.fillRect(x + (colX * cellSize / 2), y + (rowY * cellSize / 3), cellSize / 2, cellSize / 3);
              }
            });
            ctx.globalAlpha = 1.0;
          }
          
          ctx.strokeStyle = '#d1d5db';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, cellSize, cellSize);
          
          ctx.fillStyle = '#1f2937';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          const words = cell.text.split(' ');
          const maxWidth = cellSize - 10;
          let line = '';
          let lines = [];
          
          words.forEach(word => {
            const testLine = line + word + ' ';
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && line !== '') {
              lines.push(line);
              line = word + ' ';
            } else {
              line = testLine;
            }
          });
          lines.push(line);
          
          const lineHeight = 14;
          const startY = y + cellSize / 2 - ((lines.length - 1) * lineHeight) / 2;
          
          lines.forEach((line, i) => {
            ctx.fillText(line.trim(), x + cellSize / 2, startY + i * lineHeight);
          });
        });
        
        return canvas.toDataURL('image/png');
      };

      const sendDiscordNotification = async (cellIndex, colorName, action) => {
        try {
          const configSnapshot = await database.ref('bingo-config').once('value');
          const config = configSnapshot.val() || defaultConfig;
          
          if (!config.discordWebhook) {
            console.log('No Discord webhook configured');
            return;
          }

          const cellText = cells[cellIndex].text;
          const row = Math.floor(cellIndex / 6) + 1;
          const col = (cellIndex % 6) + 1;
          
          // Generate image and convert to base64
          const imageData = generateBingoImage(cells);
          const base64Image = imageData.split(',')[1];
          
          const payload = {
            embeds: [{
              title: 'Bingo Card Update (<- Click)',
              description: `**${cellText}** (Row ${row}, Col ${col})`,
              color: action === 'marked' ? 3066993 : 15158332,
              fields: [{
                name: 'Action',
                value: action === 'marked' ? `‚úì Marked with ${colorName}` : `‚úó ${colorName} removed`,
                inline: true
              }],
              url: 'https://yusiptic.github.io/bingo/',
              timestamp: new Date().toISOString()
            }]
          };
          
          // Send through Cloudflare Worker proxy
          const response = await fetch('https://bingo-discord-proxy.yusiptic.workers.dev/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              webhook: config.discordWebhook,
              payload: payload,
              imageBase64: base64Image
            })
          });
          
          if (!response.ok) {
            throw new Error(`Worker responded with ${response.status}`);
          }
          
          console.log('Discord notification sent successfully');
        } catch (error) {
          console.error('Discord notification failed:', error);
        }
      };

      const toggleColor = async (index) => {
        const newCells = [...cells];
        const colorIndex = selectedColor;
        const colorSet = new Set(newCells[index].colors);
        
        let action;
        if (colorSet.has(colorIndex)) {
          colorSet.delete(colorIndex);
          action = 'unmarked';
        } else {
          colorSet.add(colorIndex);
          action = 'marked';
        }
        
        newCells[index].colors = Array.from(colorSet);
        setCells(newCells);
        await saveMarks(newCells);
        await sendDiscordNotification(index, colors[colorIndex].name, action);
        setLastUpdate(new Date());
      };

      const exportConfig = async () => {
        const configSnapshot = await database.ref('bingo-config').once('value');
        const config = configSnapshot.val() || defaultConfig;
        
        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'bingo-config.json';
        a.click();
      };

      const importConfig = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
          const text = await file.text();
          const config = JSON.parse(text);
          await database.ref('bingo-config').set(config);
          await loadData();
          alert('Configuration imported successfully!');
        } catch (error) {
          console.error('Error importing config:', error);
          alert('Error importing configuration. Please check the file format.');
        }
      };

      const resetMarks = async () => {
        if (!confirm('Reset all marks? This cannot be undone.')) return;
        const marks = Array(36).fill([]);
        await database.ref('bingo-marks').set(marks);
        await loadData();
      };

      if (loading) {
        return (
          <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-indigo-100 to-purple-100">
            <div className="text-xl text-gray-600">Loading bingo card...</div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-indigo-100 to-purple-100 flex items-center justify-center p-4">
          <div className="w-full max-w-3xl">
            {adminMode && (
              <div className="bg-white rounded-2xl shadow-2xl p-4 mb-6">
                <div className="flex items-center justify-between">
                  <h2 className="text-xl font-bold text-gray-800">Admin Controls</h2>
                  <div className="flex gap-2">
                    <button
                      onClick={loadData}
                      className="p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition"
                      title="Refresh"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M21 2v6h-6"></path>
                        <path d="M3 12a9 9 0 0 1 15-6.7L21 8"></path>
                        <path d="M3 22v-6h6"></path>
                        <path d="M21 12a9 9 0 0 1-15 6.7L3 16"></path>
                      </svg>
                    </button>
                    <button
                      onClick={exportConfig}
                      className="p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition"
                      title="Export Config"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                      </svg>
                    </button>
                    <label className="p-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition cursor-pointer" title="Import Config">
                      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                      </svg>
                      <input type="file" accept=".json" onChange={importConfig} className="hidden" />
                    </label>
                    <button
                      onClick={resetMarks}
                      className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition text-sm"
                    >
                      Reset All
                    </button>
                  </div>
                </div>
              </div>
            )}

            <div className="bg-white p-2 sm:p-6">
              <div className="mb-3">
                <div className="flex gap-2 sm:gap-3 flex-wrap justify-center">
                  {colors.map((color, idx) => (
                    <button
                      key={idx}
                      onClick={() => setSelectedColor(idx)}
                      className={`px-4 sm:px-6 py-2 sm:py-3 rounded-lg font-semibold transition-all text-sm sm:text-base ${
                        selectedColor === idx
                          ? `${color.bg} text-white scale-105 shadow-lg`
                          : `bg-gray-200 ${color.text} hover:scale-105`
                      }`}
                    >
                      {color.name}
                    </button>
                  ))}
                </div>
              </div>

              <div className="mb-2">
                <button
                  onClick={() => setShowRules(!showRules)}
                  className="w-full p-1 border-2 border-gray-300 transition-all flex justify-between items-center"
                >
                  <span className="text-lg font-bold text-gray-800">Rewards & Punishments</span>
                  <svg 
                    className={`w-5 h-3 text-gray-600 transition-transform ${showRules ? 'rotate-180' : ''}`}
                    fill="none" 
                    stroke="currentColor" 
                    viewBox="0 0 24 24"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </button>
                
                {showRules && (
                  <div className="mt-2 p-4 border-2 border-gray-300 animate-fadeIn">
                    <div className="mb-3">
                      <h3 className="text-sm font-bold text-green-700 mb-1">üèÜ REWARD</h3>
                      <p className="text-xs sm:text-sm text-gray-800 font-bold">FIRST PLACE - COLLECTIVE GIFT FROM EVERYONE ELSE + EARN FAVOR FROM CHOSEN PERSON</p>
                    </div>
                    <div className="mb-3">
                      <h3 className="text-sm font-bold text-orange-700 mb-1">‚ö†Ô∏è PUNISHMENT</h3>
                      <p className="text-xs sm:text-sm text-gray-800 font-bold">LAST PLACE - PARTICIPATE IN LEGIT STANDUP SHOW IN CHICAGO (EVERYONE WATCHES)</p>
                    </div>
                    <div className="pt-3 border-t-2 border-red-300">
                      <p className="text-xs sm:text-sm text-red-700 font-bold text-center bg-red-100 p-2 rounded">
                        ‚ö†Ô∏è SIX OR LESS CELLS COMPLETED = TATTOO CHOSEN BY EVERYONE ELSE
                      </p>
                    </div>
                  </div>
                )}
              </div>

              <div className="grid grid-cols-6 gap-1 sm:gap-2 mb-4">
                {cells.map((cell, idx) => (
                  <div
                    key={idx}
                    onClick={() => toggleColor(idx)}
                    className="aspect-square bg-white border-2 border-gray-300 p-1 sm:p-2 cursor-pointer hover:shadow-lg transition-all relative overflow-hidden group"
                  >
                    <div className="absolute inset-0 flex flex-wrap">
                      {cell.colors.map((colorIdx, i) => (
                        <div
                          key={i}
                          className={`${colors[colorIdx].bg} opacity-30`}
                          style={{
                            width: cell.colors.length === 1 ? '100%' : '50%',
                            height: cell.colors.length <= 2 ? '100%' : cell.colors.length <= 4 ? '50%' : '33.33%'
                          }}
                        />
                      ))}
                    </div>
                    <div className="relative z-10 h-full flex items-center justify-center">
                      <span className="text-[0.5rem] sm:text-xs font-medium text-gray-800 text-center leading-tight">
                        {cell.text}
                      </span>
                    </div>
                    {cell.colors.length > 0 && (
                      <div className="absolute top-0.5 sm:top-1 right-0.5 sm:right-1 z-20 flex gap-0.5">
                        {cell.colors.map((colorIdx, i) => (
                          <div
                            key={i}
                            className={`w-1.5 h-1.5 sm:w-2 sm:h-2 rounded-full ${colors[colorIdx].bg} border border-white`}
                          />
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>

              {adminMode && lastUpdate && (
                <div className="text-sm text-gray-500 text-center">
                  Last updated: {lastUpdate.toLocaleTimeString()}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<BingoCard />, document.getElementById('root'));
  </script>
  
  <style>
    html {
        overflow-y: scroll;
        scrollbar-gutter: stable;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fadeIn {
      animation: fadeIn 0.1s ease-out;
    }
  </style>
</body>
</html>